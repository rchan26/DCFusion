% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BLR_fusion.R
\name{ea_BLR_DL_PT}
\alias{ea_BLR_DL_PT}
\title{#' @export
obtain_hypercube_centre_R <- function(bessel_layers,
                                      transform_mats,
                                      data,
                                      prior_means,
                                      prior_variances,
                                      C) {
  centre <- sapply(1:length(bessel_layers), function(d) 0.5*(bessel_layers[[d]]$L + bessel_layers[[d]]$U))
  trans_centre <- as.vector(transform_mats$to_X %*% centre)
  grad_log_hat <- as.vector(log_BLR_gradient(beta = trans_centre,
                                             y_labels = data$y,
                                             X = data$X,
                                             X_beta = as.vector(data$X %*% trans_centre),
                                             prior_means = prior_means,
                                             prior_variances = prior_variances,
                                             C = C))
  return(list('beta_hat' = trans_centre,
              'grad_log_hat' = grad_log_hat))
}
#' @export
ea_phi_BLR_DL_bounds <- function(beta_hat,
                                 dim,
                                 data,
                                 prior_means,
                                 prior_variances,
                                 C,
                                 precondition_mat,
                                 transform_mats,
                                 bessel_layers,
                                 grad_log_hat = NULL) {
  if (is.null(grad_log_hat)) {
    grad_log_hat <- as.vector(log_BLR_gradient(beta = beta_hat,
                                               y_labels = data$y,
                                               X = data$X,
                                               X_beta = as.vector(data$X%*%beta_hat),
                                               prior_means = prior_means,
                                               prior_variances = prior_variances,
                                               C = C))
  }
  # print('grad_log_hat'); print(grad_log_hat)
  vec <- as.vector(transform_mats$to_X%*%grad_log_hat)
  # print('vec'); print(vec)
  vec_norm <- sqrt(sum(vec^2))
  # print('vec_norm'); print(vec_norm)
  dist <- maximum_distance_hypercube_to_cv(dim = dim,
                                           beta_hat = beta_hat,
                                           bessel_layers = bessel_layers,
                                           transform_mats = transform_mats)
  # print('dist'); print(dist)
  P_n_Lambda <- spectral_radius_bound_BLR_Z(dim = dim,
                                            bessel_layers = bessel_layers,
                                            X = data$X,
                                            prior_variances = prior_variances,
                                            C = C,
                                            sqrt_Lambda = transform_mats$to_X)
  # print('P_n_Lambda:'); print(P_n_Lambda)
  # print('LB:'); print(-0.5*dim*P_n_Lambda)
  # print('UB:'); print(0.5*((vec_norm + dist*P_n_Lambda)^2 + dim*P_n_Lambda))
  return(list('LB' = -0.5*dim*P_n_Lambda,
              'UB' = 0.5*((vec_norm + dist*P_n_Lambda)^2 + dim*P_n_Lambda),
              'dist' = dist,
              'P_n_Lambda' = P_n_Lambda,
              't1_bds' = (vec_norm + dist*P_n_Lambda)^2,
              't2_bds' = dim*P_n_Lambda))
}
#' @export
ea_phi_BLR_DL_bounds <- function(initial_parameters,
                                 y_labels,
                                 X,
                                 prior_means,
                                 prior_variances,
                                 C,
                                 precondition_mat,
                                 transform_mat,
                                 lower,
                                 upper,
                                 bounds_multiplier) {
  if (bounds_multiplier < 1) {
    stop("ea_phi_BLR_DL_bounds: bounds_multipler should be greater than or equal to 1")
  }
  # checking that initial parameters is between lower and upper bounds
  if (!all(lower <= initial_parameters)) {
    for (d in which(lower > initial_parameters)) {
      initial_parameters[d] <- (lower[d]+upper[d])/2
    }
  }
  if (!all(upper >= initial_parameters)) {
    for (d in which(upper < initial_parameters)) {
      initial_parameters[d] <- (lower[d]+upper[d])/2
    }
  }
  LB <- optim(par = initial_parameters,
              fn = function(beta) {
                ea_phi_BLR_DL_vec(beta = beta,
                                  y_labels = y_labels,
                                  X = X,
                                  prior_means = prior_means,
                                  prior_variances = prior_variances,
                                  C = C,
                                  precondition_mat = precondition_mat,
                                  transform_mat = transform_mat)},
              method = "L-BFGS-B",
              lower = lower,
              upper = upper,
              control = list('fnscale' = 1, 'maxit' = 250))$value
  UB <- optim(par = initial_parameters,
              fn = function(beta) {
                ea_phi_BLR_DL_vec(beta = beta,
                                  y_labels = y_labels,
                                  X = X,
                                  prior_means = prior_means,
                                  prior_variances = prior_variances,
                                  C = C,
                                  precondition_mat = precondition_mat,
                                  transform_mat = transform_mat)},
              method = "L-BFGS-B",
              lower = lower,
              upper = upper,
              control = list('fnscale' = -1, 'maxit' = 250))$value
  # multiply the bounds by bounds_multiplier to compensate the case
  # that the opitimser did not get the bounds exactly correct
  # calculate the Bounds Difference
  BD <- UB-LB
  # by subtracting and adding 0.5*(bounds_multiplier-1)*BD
  # makes the resulting bounds difference be larger by a factor of bounds_multiplier
  return(list('LB' = LB - 0.5*(bounds_multiplier-1)*BD,
              'UB' = UB + 0.5*(bounds_multiplier-1)*BD))
}}
\usage{
ea_BLR_DL_PT(
  dim,
  x0,
  y,
  s,
  t,
  data,
  prior_means,
  prior_variances,
  C,
  precondition_mat,
  transform_mats,
  cv_location = "hypercube_centre",
  diffusion_estimator,
  beta_NB = 10,
  gamma_NB_n_points = 2,
  logarithm
)
}
\description{
#' @export
obtain_hypercube_centre_R <- function(bessel_layers,
                                      transform_mats,
                                      data,
                                      prior_means,
                                      prior_variances,
                                      C) {
  centre <- sapply(1:length(bessel_layers), function(d) 0.5*(bessel_layers[[d]]$L + bessel_layers[[d]]$U))
  trans_centre <- as.vector(transform_mats$to_X %*% centre)
  grad_log_hat <- as.vector(log_BLR_gradient(beta = trans_centre,
                                             y_labels = data$y,
                                             X = data$X,
                                             X_beta = as.vector(data$X %*% trans_centre),
                                             prior_means = prior_means,
                                             prior_variances = prior_variances,
                                             C = C))
  return(list('beta_hat' = trans_centre,
              'grad_log_hat' = grad_log_hat))
}
#' @export
ea_phi_BLR_DL_bounds <- function(beta_hat,
                                 dim,
                                 data,
                                 prior_means,
                                 prior_variances,
                                 C,
                                 precondition_mat,
                                 transform_mats,
                                 bessel_layers,
                                 grad_log_hat = NULL) {
  if (is.null(grad_log_hat)) {
    grad_log_hat <- as.vector(log_BLR_gradient(beta = beta_hat,
                                               y_labels = data$y,
                                               X = data$X,
                                               X_beta = as.vector(data$X%*%beta_hat),
                                               prior_means = prior_means,
                                               prior_variances = prior_variances,
                                               C = C))
  }
  # print('grad_log_hat'); print(grad_log_hat)
  vec <- as.vector(transform_mats$to_X%*%grad_log_hat)
  # print('vec'); print(vec)
  vec_norm <- sqrt(sum(vec^2))
  # print('vec_norm'); print(vec_norm)
  dist <- maximum_distance_hypercube_to_cv(dim = dim,
                                           beta_hat = beta_hat,
                                           bessel_layers = bessel_layers,
                                           transform_mats = transform_mats)
  # print('dist'); print(dist)
  P_n_Lambda <- spectral_radius_bound_BLR_Z(dim = dim,
                                            bessel_layers = bessel_layers,
                                            X = data$X,
                                            prior_variances = prior_variances,
                                            C = C,
                                            sqrt_Lambda = transform_mats$to_X)
  # print('P_n_Lambda:'); print(P_n_Lambda)
  # print('LB:'); print(-0.5*dim*P_n_Lambda)
  # print('UB:'); print(0.5*((vec_norm + dist*P_n_Lambda)^2 + dim*P_n_Lambda))
  return(list('LB' = -0.5*dim*P_n_Lambda,
              'UB' = 0.5*((vec_norm + dist*P_n_Lambda)^2 + dim*P_n_Lambda),
              'dist' = dist,
              'P_n_Lambda' = P_n_Lambda,
              't1_bds' = (vec_norm + dist*P_n_Lambda)^2,
              't2_bds' = dim*P_n_Lambda))
}
#' @export
ea_phi_BLR_DL_bounds <- function(initial_parameters,
                                 y_labels,
                                 X,
                                 prior_means,
                                 prior_variances,
                                 C,
                                 precondition_mat,
                                 transform_mat,
                                 lower,
                                 upper,
                                 bounds_multiplier) {
  if (bounds_multiplier < 1) {
    stop("ea_phi_BLR_DL_bounds: bounds_multipler should be greater than or equal to 1")
  }
  # checking that initial parameters is between lower and upper bounds
  if (!all(lower <= initial_parameters)) {
    for (d in which(lower > initial_parameters)) {
      initial_parameters[d] <- (lower[d]+upper[d])/2
    }
  }
  if (!all(upper >= initial_parameters)) {
    for (d in which(upper < initial_parameters)) {
      initial_parameters[d] <- (lower[d]+upper[d])/2
    }
  }
  LB <- optim(par = initial_parameters,
              fn = function(beta) {
                ea_phi_BLR_DL_vec(beta = beta,
                                  y_labels = y_labels,
                                  X = X,
                                  prior_means = prior_means,
                                  prior_variances = prior_variances,
                                  C = C,
                                  precondition_mat = precondition_mat,
                                  transform_mat = transform_mat)},
              method = "L-BFGS-B",
              lower = lower,
              upper = upper,
              control = list('fnscale' = 1, 'maxit' = 250))$value
  UB <- optim(par = initial_parameters,
              fn = function(beta) {
                ea_phi_BLR_DL_vec(beta = beta,
                                  y_labels = y_labels,
                                  X = X,
                                  prior_means = prior_means,
                                  prior_variances = prior_variances,
                                  C = C,
                                  precondition_mat = precondition_mat,
                                  transform_mat = transform_mat)},
              method = "L-BFGS-B",
              lower = lower,
              upper = upper,
              control = list('fnscale' = -1, 'maxit' = 250))$value
  # multiply the bounds by bounds_multiplier to compensate the case
  # that the opitimser did not get the bounds exactly correct
  # calculate the Bounds Difference
  BD <- UB-LB
  # by subtracting and adding 0.5*(bounds_multiplier-1)*BD
  # makes the resulting bounds difference be larger by a factor of bounds_multiplier
  return(list('LB' = LB - 0.5*(bounds_multiplier-1)*BD,
              'UB' = UB + 0.5*(bounds_multiplier-1)*BD))
}
}
