% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/importance_sampling_functions.R
\name{rho_IS_multivariate}
\alias{rho_IS_multivariate}
\title{rho Importance Sampling Step (multivariate)}
\usage{
rho_IS_multivariate(
  particles_to_fuse,
  dim,
  N,
  m,
  time,
  inv_precondition_matrices,
  inverse_sum_inv_precondition_matrices,
  number_of_steps = 2,
  time_mesh = NA,
  resampling_method = "multi",
  n_cores = parallel::detectCores(),
  cl = NULL
)
}
\arguments{
\item{particles_to_fuse}{list of length m, where particles_to_fuse[[c]]
contains the particles for the c-th sub-posterior
(a list of particles to fuse can be initialised by
initialise_particle_sets() function)}

\item{dim}{dimension of the particles}

\item{N}{number of particles to importance sample}

\item{m}{number of sub-posteriors to combine}

\item{time}{end time T for fusion algorithm}

\item{inv_precondition_matrices}{list of length m of inverse 
preconditioning matrices}

\item{inverse_sum_inv_precondition_matrices}{the inverse of the sum of the inverse
precondition matrices (can be 
calculated by passing the inverse 
precondition matrices into inverse_sum_matrices())}

\item{number_of_steps}{integer value for number of steps in the Fusion algorithm
(default is 2 for Monte Carlo Fusion)}

\item{time_mesh}{vector of times used in Fusion algorithm (default is NA). If
set to NA, the returned particle has time_mesh given by c(0, time)}

\item{resampling_method}{method to be used in resampling, default is multinomial 
resampling ('multi'). Other choices are stratified 
resampling ('strat'), systematic resampling ('system'),
residual resampling ('resid')}

\item{n_cores}{number of cores to use}

\item{cl}{an object of class "cluster" for parallel computation in R. If none
is passed, then one is created and used within this function}
}
\value{
A importance weighted particle set
}
\description{
Performs the importance sampling step for rho where target is univariate
}
\examples{
samples_to_fuse <- lapply(1:2, function(i) mvrnormArma(100, c(0, 0), diag(2)))
particles_to_fuse <- initialise_particle_sets(samples_to_fuse = samples_to_fuse,
                                              multivariate = TRUE)
precondition_mats <- lapply(samples_to_fuse, cov)
inv_precondition_mats <- lapply(precondition_mats, solve)
inv_sum_inv_precondition_mats <- inverse_sum_matrices(inv_precondition_mats)
particles <- rho_IS_multivariate(particles_to_fuse = particles_to_fuse,
                                 N = 100,
                                 dim = 2,
                                 m = 2,
                                 time = 0.5,
                                 inv_precondition_matrices = inv_precondition_mats,
                                 inverse_sum_inv_precondition_matrices = inv_sum_inv_precondition_mats)

}
