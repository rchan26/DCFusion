% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/importance_sampling_functions.R
\name{rho_IS_multivariate}
\alias{rho_IS_multivariate}
\title{rho Importance Sampling Step (multivariate)}
\usage{
rho_IS_multivariate(
  particles_to_fuse,
  dim,
  N,
  m,
  time,
  inv_precondition_matrices,
  inverse_sum_inv_precondition_matrices
)
}
\arguments{
\item{particles_to_fuse}{list of length m, where particles_to_fuse[[c]]
contains the particles for the c-th sub-posterior
(a list of particles to fuse can be initialised by
initialise_particle_sets() function)}

\item{dim}{dimension of the particles}

\item{N}{number of particles to importance sample}

\item{m}{number of sub-posteriors to combine}

\item{time}{time T for fusion algorithm}

\item{inv_precondition_matrices}{list of length m of inverse 
preconditioning matrices}

\item{inverse_sum_inv_precondition_matrices}{the inverse of the sum of the inverse
precondition matrices (can be 
calculated by passing the inverse 
precondition matrices into inv_sum_matrices())}
}
\value{
A importance weighted particle set
}
\description{
Performs the importance sampling step for rho where target is univariate
}
\examples{
samples_to_fuse <- lapply(1:2, function(i) mvrnormArma(100, c(0, 0), diag(2)))
particles_to_fuse <- initialise_particle_sets(samples_to_fuse = samples_to_fuse,
                                              multivariate = TRUE)
precondition_mats <- lapply(samples_to_fuse, cov)
inv_precondition_mats <- lapply(precondition_mats, solve)
inv_sum_inv_precondition_mats <- inv_sum_matrices(inv_precondition_mats)
particles <- rho_IS_multivariate(particles_to_fuse = particles_to_fuse,
                                 N = 100,
                                 dim = 2,
                                 m = 2,
                                 time = 0.5,
                                 inv_precondition_matrices = inv_precondition_mats,
                                 inverse_sum_inv_precondition_matrices = inv_sum_inv_precondition_mats)

}
